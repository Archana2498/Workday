<?xml version="1.0" encoding="UTF-8"?><record_update table="scheduled_import_set">
    <scheduled_import_set action="INSERT_OR_UPDATE">
        <active>true</active>
        <business_calendar/>
        <concurrent_import>false</concurrent_import>
        <condition><![CDATA[var glideWorkdayJobTracker = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_SERVICE_JOB_TRACKER_TABLE);
glideWorkdayJobTracker.addQuery('job_state', 'running');
glideWorkdayJobTracker.addQuery('workday_integration_service', 'termination');
glideWorkdayJobTracker.query();
var result = true;
if (glideWorkdayJobTracker.next()) {
	gs.info(glideWorkdayJobTracker.scheduled_import+" - Scheduled Import is already running");
    //gs.info(gs.getMessage("'{0}' - Scheduled Import is already running",[glideWorkdayJobTracker.scheduled_import]));
    result = false;
}
result;]]></condition>
        <conditional>true</conditional>
        <connection_override/>
        <data_source display_value="Workday Termination">cef11b1b47116150901d3a34846d43ed</data_source>
        <entered_time/>
        <map/>
        <max_drift/>
        <name>Workday Termination Import</name>
        <offset/>
        <offset_type>0</offset_type>
        <order/>
        <parent/>
        <partition_method>roundRobin</partition_method>
        <partition_script><![CDATA[(function partitionHash(import_set_row) {

	// Add your code here
	
	// eg:
	// return import_set_row.u_important_category;
	// This would ensure all rows with the same 'u_important_category' value will be in the same Import Set.

	 return import_set_row.sys_import_row;

})(import_set_row);]]></partition_script>
        <partition_size/>
        <post_script/>
        <post_script_bool>false</post_script_bool>
        <pre_script><![CDATA[try {
	var job_tracker = new ImportSetUtilsSNC().createJobTracker();
	gs.info("job tracker1"+ job_tracker);

	var grMainJob = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_JOB_TRACKER_TABLE);
	grMainJob.addQuery("state", "running");
	grMainJob.orderByDesc('sys_created_on');
	grMainJob.setLimit(1);
	grMainJob.query();
	if (grMainJob.next()) {
		var grMainJobSysId = grMainJob.sys_id;

		try {
			var attachment = new GlideSysAttachment();
			var agr = attachment.getAttachments('sys_data_source', data_source.sys_id);
			while (agr.next()) {
				attachment.deleteAttachment(agr.getValue('sys_id'));
			} //delete attachments exits already in data source


			var newJobTrackerRecord = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_SERVICE_JOB_TRACKER_TABLE);
			newJobTrackerRecord.initialize();
			newJobTrackerRecord.import_set = import_set.sys_id;
			newJobTrackerRecord.job_state = 'running';
			newJobTrackerRecord.job_type = 'scheduled';
			newJobTrackerRecord.workday_integration_service = 'termination';
			newJobTrackerRecord.workday_integration_job_tracker = grMainJobSysId;
			newJobTrackerRecord.job_started_at = new GlideDateTime();

			//var pullNextChunk;
			//initial load for specified configured parameter when no records are there in workday todos inbound table else take latest workday last functional updated date as start_date_time in action's input.
			var glidePullToDosConfiguration = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_CONFIGURATIONS_TABLE);
			glidePullToDosConfiguration.addQuery('active', true);
			glidePullToDosConfiguration.orderByDesc('sys_created_on');
			glidePullToDosConfiguration.setLimit(1);
			glidePullToDosConfiguration.query();
			if (glidePullToDosConfiguration.next()) {
				var inputs = {};
				//var startDateTimeJob,endDateTimeJob;
				// var glideWorkdayJobTracker = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_SERVICE_JOB_TRACKER_TABLE);
				// glideWorkdayJobTracker.addQuery('job_state', 'completed');
				// glideWorkdayJobTracker.addQuery('workday_integration_service', 'time_off_requests');
				// glideWorkdayJobTracker.orderByDesc('end_date_time_api_parameter');
				// glideWorkdayJobTracker.setLimit(1);
				// glideWorkdayJobTracker.query();
				// if (glideWorkdayJobTracker.next()) {
				// 	//inputs['start_date_time'] = new ImportSetUtils().getConvertedDateTime(new GlideDateTime(glideWorkdayJobTracker.end_date_time_api_parameter).getValue());
				// 	startDateTimeJob =  new GlideDateTime(glideWorkdayJobTracker.end_date_time_api_parameter).getDisplayValue();
				// 	var gdt = new GlideDateTime(glideWorkdayJobTracker.end_date_time_api_parameter.toString());
				// 	var ms = glidePullToDosConfiguration.load_interval.dateNumericValue();
				// 	gdt.add(ms);
				// 	var endDateTime = gdt.getDisplayValue();
				// 	if (gdt.getNumericValue() > new GlideDateTime(grMainJob.job_started_at).getNumericValue()) {
				// 		//inputs['end_date_time'] = new ImportSetUtils().getConvertedDateTime(new GlideDateTime(grMainJob.job_started_at).getValue());
				// 		endDateTimeJob = new GlideDateTime(grMainJob.job_started_at).getDisplayValue();
				// 		pullNextChunk = false;
				// 	} else {
				// 		//inputs['end_date_time'] = new ImportSetUtils().getConvertedDateTime(gdt.getValue());
				// 		endDateTimeJob = endDateTime;
				// 		pullNextChunk = true;
				// 	}
				// } else {
				// 	//inputs['start_date_time'] = new ImportSetUtils().getConvertedDateTime(new GlideDateTime(glidePullToDosConfiguration.initial_load_start_datetime).getValue());
				// 	startDateTimeJob = new GlideDateTime(glidePullToDosConfiguration.initial_load_start_datetime).getDisplayValue();
				// 	var gdt1 = new GlideDateTime(glidePullToDosConfiguration.initial_load_start_datetime.toString());
				// 	var ms1 = glidePullToDosConfiguration.load_interval.dateNumericValue();
				// 	gdt1.add(ms1);
				// 	var endDateTime1 = gdt1.getDisplayValue();
				// 	if (gdt1.getNumericValue() > new GlideDateTime(grMainJob.job_started_at).getNumericValue()) {
				// 		//inputs['end_date_time'] = new ImportSetUtils().getConvertedDateTime(new GlideDateTime(grMainJob.job_started_at).getValue());
				// 		endDateTimeJob = new GlideDateTime(grMainJob.job_started_at).getDisplayValue();
				// 		pullNextChunk = false;
				// 	} else {
				// 		//inputs['end_date_time'] = new ImportSetUtils().getConvertedDateTime(gdt1.getValue());
				// 		endDateTimeJob = endDateTime1;
				// 		pullNextChunk = true;
				// 	}
				// }

				// newJobTrackerRecord.start_date_time_api_parameter = startDateTimeJob;
				// newJobTrackerRecord.end_date_time_api_parameter = endDateTimeJob;
				// if (!gs.nil(pullNextChunk)) {
				// 	newJobTrackerRecord.pull_next_chunk = pullNextChunk;
				// }
				newJobTrackerRecord.pull_next_chunk = false;
				newJobTrackerRecord.insert();

				inputs['report_owner_username'] = glidePullToDosConfiguration.workday_to_dos_report_owner_username;
				inputs['report_name'] = 'RPT_termination_report';//glidePullToDosConfiguration.workday_to_dos_raas_report_name;
				inputs['data_source_reference'] = data_source;
				inputs['business_processes'] = 'cd09bb46446c11de98360015c5e6daf6';
				inputs['transaction_status'] = 'b90bc51be01d4ae99b603b02b073714d!81f119504b754cadb16ecf27e09e5b25!d598e64d72444e0ea1d39bb88a52b601!1b0f3f40cfaa48dd9f1c86a154a1232a!ef202aa58740484d9c7f96fd8b1a637d!e2d08afc53614c37b32b31270bb8bee3';

				//inputs['workday_id']='4db8928213520103a1320c6466273341';
				var outputs = sn_fd.FlowAPI.executeAction('sn_workday_hr_spke.look_up_termination_requests', inputs, 1800000);
				var status = outputs['status']; // Choice
				var error_message = outputs['error_message'];

				if (status == 'Error') {
					var updateJobTrackerRecord1 = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_SERVICE_JOB_TRACKER_TABLE);
					if (updateJobTrackerRecord1.get(newJobTrackerRecord.sys_id)) {
						updateJobTrackerRecord1.job_state = 'failed';
						updateJobTrackerRecord1.error_source = 'api_error';
						updateJobTrackerRecord1.error_message = error_message;
						updateJobTrackerRecord1.job_ended_at = new GlideDateTime();
						updateJobTrackerRecord1.update();

						grMainJob.state = 'failed';
						grMainJob.error_message = error_message;
						grMainJob.job_ended_at = new GlideDateTime();
					}
				}
			} else {
				// if (!gs.nil(pullNextChunk)) {
				// 	newJobTrackerRecord.pull_next_chunk = pullNextChunk;
				// }
				newJobTrackerRecord.pull_next_chunk = false;
				newJobTrackerRecord.error_source = 'configuration_error';
				newJobTrackerRecord.job_state = 'failed';
				newJobTrackerRecord.error_message = gs.getMessage("No active workday pull to-dos configuration record found");
				newJobTrackerRecord.job_ended_at = new GlideDateTime();
				newJobTrackerRecord.insert();

				grMainJob.state = 'failed';
				grMainJob.error_message = gs.getMessage("No active workday pull to-dos configuration record found");
				grMainJob.job_ended_at = new GlideDateTime();
			}
		} catch (ex) {

			var updateJobTrackerRecord3 = new GlideRecord(new WorkdayPullToDosHelper().WORKDAY_SERVICE_JOB_TRACKER_TABLE);
			if (updateJobTrackerRecord3.get(newJobTrackerRecord.sys_id)) {
				updateJobTrackerRecord3.job_state = 'failed';
				updateJobTrackerRecord3.error_source = 'api_error';
				updateJobTrackerRecord3.error_message = ex.getMessage() + "\n" + "Please check system error logs or flow designer executions";
				updateJobTrackerRecord3.job_ended_at = new GlideDateTime();
				updateJobTrackerRecord3.update();
			}
			grMainJob.state = 'failed';
			grMainJob.error_message = ex.getMessage() + "\n" + "Please check system error logs or flow designer executions";
			grMainJob.job_ended_at = new GlideDateTime();
			grMainJob.update();
			var message = ex.getMessage();
			gs.error(message);
		}
		grMainJob.update();
	}
} catch (ex) {
	var msg = ex.getMessage();
	gs.error(msg);
}]]></pre_script>
        <pre_script_bool>true</pre_script_bool>
        <record_source>regular</record_source>
        <run_as display_value="System Administrator">6816f79cc0a8016401c5a33be04be441</run_as>
        <run_as_tz/>
        <run_dayofmonth>1</run_dayofmonth>
        <run_dayofweek>1</run_dayofweek>
        <run_period/>
        <run_start>2023-03-06 11:08:24</run_start>
        <run_time>1970-01-01 08:00:00</run_time>
        <run_type>daily</run_type>
        <show_connection_override>false</show_connection_override>
        <synchronize_inserts>true</synchronize_inserts>
        <sys_class_name>scheduled_import_set</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2023-03-06 11:09:26</sys_created_on>
        <sys_id>8d0fa39347916150901d3a34846d433e</sys_id>
        <sys_mod_count>7</sys_mod_count>
        <sys_name>Workday Termination Import</sys_name>
        <sys_package display_value="HR Service Delivery Integration with Workday" source="sn_hr_workday">d4fb8bd8db5b0010205cdf6b5e96190e</sys_package>
        <sys_policy/>
        <sys_scope display_value="HR Service Delivery Integration with Workday">d4fb8bd8db5b0010205cdf6b5e96190e</sys_scope>
        <sys_update_name>scheduled_import_set_8d0fa39347916150901d3a34846d433e</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-03-09 11:24:10</sys_updated_on>
        <time_zone/>
        <upgrade_safe>false</upgrade_safe>
        <use_child_connection>false</use_child_connection>
    </scheduled_import_set>
</record_update>
